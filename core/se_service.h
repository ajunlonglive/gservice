/*************************************************************************************
*	自定义标准头文件
*	整数使用C99中的stdint.h
*************************************************************************************/
#ifndef SE_8B3E1136_A9CF_45B4_BEA8_36DB36878690
#define SE_8B3E1136_A9CF_45B4_BEA8_36DB36878690

#include <pthread.h>
#include <libpq-fe.h>
#include "../gsoap/stdsoap2.h"
#include "../gsoap/json.h"
#include "se_std.h"
// Max. request backlog
#define BACKLOG (128) 

/*****************************************************************************
*	安全清理本次soap占用的资源
*****************************************************************************/
#define SE_soap_clear(soap_) do {\
	if(!SE_PTR_ISNULL(soap_)){\
		soap_destroy(soap_);\
		soap_end(soap_);\
	}\
} while (0);


/*****************************************************************************
*	安全释放soap对象
*****************************************************************************/
#define SE_soap_free(soap_) do {\
	if(!SE_PTR_ISNULL(soap_)){\
		soap_destroy(soap_);\
		soap_end(soap_);\
		soap_free(soap_);\
		soap_ = NULL;\
	}\
} while (0);

/*****************************************************************************
*	安全断开与PG的连接
*****************************************************************************/
#define SE_PQfinish(ptr) do {\
	if (!SE_PTR_ISNULL(ptr)) {\
		PQfinish(ptr); ptr = NULL;\
	}\
} while (0);

/*****************************************************************************
*	安全释放清理PG查询的返回结果
*****************************************************************************/
#define SE_PQclear(ptr) do {\
	if (!SE_PTR_ISNULL(ptr)) {\
		PQclear(ptr); ptr = NULL;\
	}\
} while (0);


struct SE_QUEUE;
struct SE_PGITEM;
struct SE_PGCLUSTER;
struct SE_SHARED_LOCK;
struct SE_SHARED;
struct SE_WORKINFO;

/*****************************************************************************
*	处理进程函数指针类型
*	所有请求的处理入口点是这个函数指针
*****************************************************************************/
typedef  void(*SE_process)(struct SE_WORKINFO *obj);

/*****************************************************************************
*	队列结构
*****************************************************************************/
struct SE_QUEUE {
	//队列头
	int32_t head;
	//队列尾
	int32_t tail;
	//请求队列
	SOAP_SOCKET *queues;
};


/*****************************************************************************
*	数据库连接信息
*****************************************************************************/
struct SE_PGITEM {
	//------------------------------------------------------------------------	
	//在此范围内的数据用户不要修改,否则会导致无法预料的异常
	//当前数据库时区偏移(单位为秒)。
	int32_t time_zone;
	//初始化设置的权限系数.这个值不会改变
	int32_t	weight;
	//当前权重系数.
	int32_t current_weight;
	//当前连接自定义编号
	int32_t id;
	//物理服务器编号->指向配置文件中的databases索引号
	int32_t serverid;
	//当前PG连接使用计数,当前连接使用次数超过PGCONN_MAX_COUNT时重新连接
	//目的是提升程序的健壮性,减少pg服务器使用的无效内存
	int32_t use_count;
	//当前PG连接连接是否在使用中
	bool isuse;
	//------------------------------------------------------------------------


	//已经打开的PG连接,无需关闭或释放资源
	PGconn *conn;
};

/*****************************************************************************
*	数据库集群配置信息
*	只写数据库服务器打开的连接数为配置文件中的max_connection
*	只读数据库服务器打开的连接数为配置文件中的所有只读服务器的max_connection累加
*	具体使用那个连接采用平滑加权轮询算法分配
*****************************************************************************/
struct SE_PGCLUSTER {
	//PG集群连接数
	int32_t count;
	//PG集群连接对象数组
	struct SE_PGITEM **items;
};

/*****************************************************************************
*	共享对象锁
*****************************************************************************/
#define SE_THREAD_MUTEX		(1)
#define SE_THREAD_COND		(1<<1)
struct SE_SHARED_LOCK {
	//互斥锁
	pthread_mutex_t *mutex;
	//条件变量,它是系统使用的,用户不要使用.
	pthread_cond_t *cond;
};

/*****************************************************************************
*	服务共享对象结构,用户不要使用,请通过相关函数获取信息
*****************************************************************************/
struct SE_SHARED {
	//服务是否正在运行
	bool isrun;
	//队列对象
	struct SE_QUEUE *queue;
	//服务控制线程
	pthread_t tctrl;
	//锁初始华标志
	int32_t lock_flag;
	//线程锁
	struct SE_SHARED_LOCK *locks;
	//可读写数据库集群
	struct SE_PGCLUSTER *wcluster;
	//只读写数据库集群
	struct SE_PGCLUSTER *rcluster;
	//配置文件信息
	const struct SE_CONF *conf;
};

/*****************************************************************************
*	各工作线程使用的对象
*****************************************************************************/
struct SE_WORKINFO {
	//当前SE_WORKINFO的编号
	int32_t id;
	//sql命令缓冲区
	StringBuilder sql;
	//其它字符缓冲区
	StringBuilder buf;
	//------------------------------------------------------------------------
	//	以下对象是每次请求后绑定到SE_WORKINFO的,无需释放以下对象
	//------------------------------------------------------------------------
	//当前请求处理的SOAP对象
	struct soap *tsoap;
	//当前请求处理的请求对象
	struct value *request;
	//------------------------------------------------------------------------
	//	当前数据库连接对象
	//	因为不知道是要使用的是可读写数据库服务器还是只读的数据库服务器
	//	所以在使用时必须由用户手动调用get_next_dbserver获取
	// 这个对象无需释放,它由系统自动处理
	// 只应使用PGconn *conn,其它对象都是由系统使用的,修改会导致不可预计的结果	
	//------------------------------------------------------------------------
	struct SE_PGITEM *pg;
	//------------------------------------------------------------------------
	/*不要使用这个变量,它是由系统使用的*/
	SE_process process;
	/*不要使用这个变量,它是由系统使用的*/
	StringBuilder sys;
	//------------------------------------------------------------------------
};

#ifdef __cplusplus
extern "C" {
#endif	/*__cplusplus 1*/

	/*************************************************************************************
	*	全局对象数据共享区,不要使用这个对象,它是由系统使用的
	*************************************************************************************/
	extern struct SE_SHARED *global_shared;

	/*************************************************************************************
	*	启动服务
	*	Parameter:
	*		[in] const struct SE_CONF * const conf _ 配置信息
	*		[in] SE_process process _ 用户处理请求进程回调函数
	*************************************************************************************/
	extern bool SEAPI SE_start(const struct SE_CONF * const conf, SE_process process);

	/*************************************************************************************
	*	停止服务
	*************************************************************************************/
	extern void SEAPI SE_stop();

	/*************************************************************************************
	*	获取共享锁
	*************************************************************************************/
	extern struct SE_SHARED_LOCK * SEAPI SE_shared_lock();

	/*************************************************************************************
	*	获取一个可用的database服务器连接.
	*	Parameter:
	*		[in] struct SE_WORKINFO * arg - 工作信息对象
	*		[in] bool iswrite - 读写或只读database
	*	Returns: :成功返回struct SE_PGITEM *对象指针,否则返回NULL
	*************************************************************************************/
	extern struct SE_PGITEM * SEAPI get_dbserver(struct SE_WORKINFO *arg, bool iswrite);

	/*************************************************************************************
	*	获取配置信息
	*************************************************************************************/
	extern const struct SE_CONF *SEAPI get_conf();

	/*************************************************************************************
	*	获取JWT密钥
	*	Remake:密钥长度固定为16字节
	*************************************************************************************/
	extern const char * SEAPI get_jwt_key();
#ifdef __cplusplus
};
#endif  /*__cplusplus 2*/

#endif	/* SE_8B3E1136_A9CF_45B4_BEA8_36DB36878690 */